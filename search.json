[{"title":"1.Linux基础命令","url":"/2024/12/14/1-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","content":"如何理解文件：\n文件本文件\n\n在磁盘上创建，因为内存具有掉电易失性\n如果创建了一个空文件，也会占有磁盘空间\n文件&#x3D;文件的内容（数据）+文件的属性（元数据）（属性也是数据）\n故文件的实际占有内存大于标的内存（数据）\n\n\n操作文件：\n\n操作文件的内容\n操作文件的属性\n\n\n文件之间（普通文件 vs 目录）：\n\n普通文件\n目录-&gt;文件夹-&gt;保存其他文件的场所\n\n\n\n文件的简单命令：\n\n\nclear\n清楚屏幕上显示的内容\n\n\n\n\n\n\ntouch 文件名\n创建一个普通文件若文件已存在，会更新文件的修改时间\n\n\n\nstat 文件名\n显示文件详细信息，包括修改时间属性等\n\n\nmkdir 文件名\n创建一个空目录\n\n\nmkdir-p\n创建一串路径\n\n\nrmdir 目录名\n只能删除空目录（若目录非空，则无法删除）\n\n\nrm 文件名\n默认删除普通文件，但不能删除目录\n\n\nrm -r 文件名\n递归删除，删除这整个目录\n\n\nrm -i\n询问是否删除\n\n\nrm -f 文件名\n强行删除，不会再询问是否删除（f：force）\n\n\nrm -rf 文件名\n递归强制删除指定的目录及其内部文件\n\n\nrm -rf &#x2F;\n系统直接挂掉\n\n\n\n\n\nls\n显示当前路径下的文件或文件或目录名称\n\n\n\nls -l\n显文件或目录以及更详细的属性信息\n\n\nls -all（简写为-a）也可以写为：ll\n列出目录下的所有文件，包括.开头的隐藏文件\n\n\nls 文件名ls -l 文件名ls -ld 文件名\n1.只显示这一个文件2.显示文件里面的内容3.显示该文件本身的属性\n\n\n-d\n不进入目录，显示本身\n\n\n-r\n对目录反向排序\n\n\n-t\n以时间排序\n\n\n-R\n列出所有子目录下的文件（递归）\n\n\n\n\n\n\n\n\n\ncd  &#x2F;你的文件名&#x2F;\n切换路径，进入某个目录\n\n\n\n.\n一个.当前目录\n\n\n..\n两个..是上级目录\n\n\ncd .\n当前目录\n\n\ncd ..\n返回上一个目录如果不断回退，会一直回退到根目录，无法再回退\n\n\ncd -\n回到之前最近一次所处的路径（可以在两个热点路径下来回切换）\n\n\n绝对路径：\n从根目录开始，查找某一个文件，具有唯一性\n\n\n相对路径：\n不从根目录，根据当前位置，去查找某个目录下的某个文件\n\n\n\n\n\npwd\n显示当前用户所在的路径\n\n\n\n&#x2F;\n路径分隔符\n\n\n\n\n\ntree\n以树形结构显示目录\n\n\n\nyum install -y tree\n安装tree\n\n\nwhoami\n查询当前是哪个用户正在使用系统\n\n\ncd ~\n进入当前用户的目录\n\n\n&#x2F;home&#x2F;名字\n叫做某用户的工作路径（家目录）特命用户登录时，默认所处的路径\n\n\n\n\n\nman 命令\n显示命令的用法，man是一个查看命令，系统调用，C接口的手册，手册是有编号的\n\n\n\n安装man\nyum install man只能在root用户下安装\n\n\nman touch\ntouch的用法\n\n\nman priintf\nprintf的用法\n\n\nman 3 printf\n3号手册里printf的用法，若不带号，默认从1开始查，查到停止\n\n\n1\nshell命令\n\n\n2\n系统接口\n\n\n3\nC语言库\n\n\n进入以后：\n按q退出\n\n\n\n\n\ncp src dst\n拷贝命令，把src文件拷贝到dst里面\n\n\n\ncp -r 文件\n拷贝文件目录，命令和rm是一样的\n\n\ncat 文件名\n打印文件的内容，如cat a.txt是打印a.txt里面的内容\n\n\necho\n向显示器显示信息的命令，跟printf一样，但没有格式化，把所有内容都显示出来\n\n\n\n\n\nmv src dst\n移动命令，类似于剪切功能，同时还能对文件或目录进行重命名，这里不用带-r\n\n\n\n注意事项\nmv移到一些目录会有权限问题 ，有-r和-f选项，和前面用法一样\n\n\n写一个输出10000行字符串的命令行脚本：cnt=0; \nwhile [ $cnt -le 10000 ];\ndo echo &quot;hello world&quot; [$cnt];\nlet cnt++;\ndone &gt; test.txt\n\n查看大文本（日志）：\n\n\ncat 选项 文件\n查看目标文件的内容，但是cat是一次全输出，不适合查看大文本\n\n\n\n-b\n对非空输出行编号\n\n\n-n\n对输出的所有行编号\n\n\n-s\n不输出多行空行\n\n\ntac\n逆序输出\n\n\n\n\n\nmore\n和cat一样一屏打满就不再打了\n\n\n\n-n\nn为指定的行，就可以查看指定行的内容\n\n\n&#x2F;\n在more中输入&#x2F;有搜索功能\n\n\n\n\n\nless\n和前面一样，但是支持上下翻，q退出\n\n\n\n\n\n\nhead -n 文件\n查看文件头部的几行，n为指定的行，默认为10行\n\n\n\ntail\n查看尾部的几行\n\n\n如何查看中间部分的内容：\n临时文件\n管道：\n都是传输资源的\n一个入口，一个出口\n管道的命令行操作： head -1010 test.txt | tail -10 \n#这里|前的默认将输出结果打印到管道空间中，tail再去读取\n\n\n组合用法：   head -1010 test | tail -10 | tac | head -3\n\n时间相关的指令\n\n\ndata\n显示时间\n\n\n\ndata +%Y&#x2F;%m&#x2F;%d-%H:%M:%S\n格式化显示,这里面的格式可以随便调整\n\n\ndata +%s\n时间戳，从1970年1.1凌晨0：00到现在所经过的秒数\n\n\ndata +%Y&#x2F;%m&#x2F;%d-%H:%M:%S -d@时间戳\n转化成我们认识的时间戳\n\n\ncal 年\n看日历\n\n\n\n\n\nfind -name\n查找命令，因为可能要访问磁盘，进而导致效率低下\n\n\n\nfind pathname -options\n在文件树中查找文件\n\n\nwhich       指令\n只能搜索命令，所使用的命令在哪个目录下\n\n\nwhereis  名称\n查找范围比which范围更大比find查找范围更小，作用好是只要包含关键字都找出来\n\n\n\n\n\nalias 新命令 &#x3D; ‘原命令’\n对命令进行重命名\n\n\n\n\n\n\ngrep\n文本内容的行过滤工具，会匹配文本中的关键字，匹配上的进行行显示\n\n\n\ngrep ‘a’ test.txt\n就会在test.txt中查找a来匹配，含a的全部显示出来\n\n\n-n\n输出行号\n\n\n-i\n忽略大小写\n\n\n-v\n反向选择，把没有关键字的显示出来\n\n\n补充\ngrep可以结合管道和其他命令一起使用，过滤关键内容 grep ‘a’ test.txt | wc -l #统计行数\n\n\n\n\nsort file.txt\n对文本内容进行排序（按照ascall码值）\n\n\n\nuniq\n对文本相邻内容进行去重\n\n\n组合使用sort file.txt | uniq\n先排序，后去重\n\n压缩包\nzip\n\n\n安装zip yum install zip unzip\n使用  zip -r my.zip  unzip my.zip -d &#x2F;路径  #解压缩到指定目录，若不‘加-d 路径’，默认为当前目录\n注：打包和压缩是两个概念，打包和压缩的目的是便于传输，同时压缩包不存在下载丢失问题，因为体积小，传输更高效\n\n\ntar\n\n\n\n\ntar -czf my.tar.gz file\n对文件打包并压缩\n\n\n\ntar -xzf my.tar.gz\n解包并解压\n\n\n-v\n把解包的过程也打印出来\n\n\n-tf\n不解压查看tar.gz里面的文件\n\n\n-C（大写C）\n解压到指定目录\n\n\n\n\n\nbc\n计算器\n\n\n\necho “1+2+3”  | bc\n管道\n\n\n\n\n\nuname -a\n显示系统信息\n\n\n\nuname -r\n查看内核版本（体系结构：cpu架构）\n\n\n几个热键\n\n\nTab\n命令自动补齐\n\n\n\nctrl C\n终止在前台的异常程序，比如死循环\n\n\nCtrl r\n根据命令片段去搜索历史命令，左右即可选中\n\n\nCtrl d\n退出当前用户\n\n\n\\\n可以用来回车接着输入命令 ,对命令进行续行（其实C语言也可以）\n\n\n补充几条指令查看CPUlscpu\n\n查看内存情况lsmem\n\n查看磁盘结构df -h\n\n查看当前都有谁登录了Linux系统  who\n\n","categories":["Linux教程"],"tags":["Linux","Debian","Shell"]},{"title":"2.1数值型数据","url":"/2025/03/18/2-1%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE/","content":"第二章：数据的表示、运算和校验计算机中的信息可分为两大类：\n\n计算机处理的对象：泛称为数据\n数值型数据\n非数值型数据\n\n\n控制计算机工作的信息：泛称为控制信息\n基本依据是指令信息\n\n\n\n2.1数值型数据2.1.1进位计数制1.计算机常用的进位制(1)二进制只有0、1两个数，逢2进位或借1当2，基数r&#x3D;2\n(2)八进制0～7，8个数，逢8进位，基数r&#x3D;8\n二进制与八进制转换：3个二进制位表示1个8进制位，1个八进制位可以表示3个二进制位（“二-八进制数”）\n(3)十六进制0～15，逢16进位，基数r&#x3D;16，可以用H作为后缀表示十六进制数\n十六进制与二进制转换：4位二进制数对应1位16进制数，1位十六进制数对应4位二进制数（“二-十六”缩写）\n(4)二-十进制计算机对十进制十进制数进行处理：有两种方法：\n\n第一种：\n十进制数输入计算机，“十翻二”转换成二进制处理，再“二翻十”转换为十进制输出。适合处理科学计算任务，原始数据量不大二运算处理比较复杂，可以使用这种方式。\n\n第二种：“二-十进制”\n4位二进制数表示1位十进制数，这种编码称为BCD码（Binary Coded Deciaml），又称8421码\n\n\n十进制和二-十进制转换：1位十进制数用4位二进制数代替\n\n在编写程序时，通常用十进制数表示数值，用十六进制数或八进制数表示地址码。\n在计算机内部硬件操作时，用二进制或二-十进制表示数值，用二进制表示地址码。\n\n2.各种进位制之间的相互转换(1)十进制整数转换为二进制整数\n减权定位法\n除基取余法\n\n(2)十进制小数转换为二进制小数\n减权定位法\n乘基取余法\n\n(3)二进制整数转换为十进制整数\n按权相加法\n逐次乘基相加法\n\n(4)二进制小数转换为十进制小数\n按权相加法\n逐次乘基取余法\n\n2.1.2带符号数的表示定义两个术语:\n\n真值:日常书写习惯中用正负号加绝对值来写的数值\n\n机器数:在计算机内部使用的,连同数符一起使用的数\n\n\n1.原码表示法数码序列最高位为符号位，0表示正1表示负。其余部分为数值位。\n根据该约定，可分别得到纯小数（定点小数）与纯整数（定点整数）的原码定义式如下：\n若定点小数的原码序列为:$$X_0.X_1X_2……X_n$$则：$$[X]_{\\text{原}} &#x3D; \\begin{cases}X, &amp; 0 \\leq X &lt; 1 \\1 - X &#x3D; 1 + |X|, &amp; -1 \\leq X \\leq 0\\end{cases}$$\n","categories":["“计算机组成原理”"],"tags":["“笔记”"]},{"title":"C语言自定义类型","url":"/2025/03/16/C%E8%AF%AD%E8%A8%80%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/","content":"结构体、枚举、联合自定义类型，区别与C语言的自带类型(int、char、double等)，由我们自己定义。\n在C语言中共有3种自定义类型，分别是：结构体、枚举类型和联合体\n\n结构体结构体是一个集合类型，在结构体内，我们可以定义多个变量，这些变量称为成员变量。\n结构体的声明：struct tag  //struct + 标签&#123;   //成员变量    ......&#125;;//最后要加上‘;’分号\n\n例如想要声明一个学生的类型的结构体：\nstruct Student\t//学生类型的结构体&#123;    char name[20]; //姓名    int age;\t\t//年龄    double height;\t//身高    char id[10];\t//学号    //......    //其他属性均可自己来定义&#125;;\n\n特殊的声明：当我们想要创建的对象只需要使用一次，可以不写结构体名称，即：匿名结构体\nstruct &#123;    int x;    int y;&#125;a;\n\nstruct&#123;\tint x;\tint y;\tint z;&#125;arr[20],*p;\n\n结构体的定义与初始化有了类型，我们就可以定义变量，就像知道int类型就可已定义int类型的变量一样\nstruct Point&#123;    int x;    int y;    int z;&#125;p1;  //在声明类型的同时定义变量p1struct Point p2; //定义结构体变量p2//p1与p2的定义是一样的，唯一的区别是若p2在函数内部定义（如main函数）时会变成局部变量//初始化：定义变量的同时赋值struct Point p3 = &#123;1,2,3&#125;;//c99标准中支持了不按顺序初始化：struct Point p4 = &#123;.z=3,.x=1,.y=2&#125;;struct Student&#123; char name[20]; int age;      &#125;;//定义之后再初始化struct Student s1; s1 = (struct Student)&#123;&quot;张三&quot;, 18&#125;;//需要显式类型转换，不推荐struct Node&#123;    int data;    struct Point p;    struct Node* next;&#125;n1 = &#123;6,&#123;1,2,3&#125;,NULL&#125;;//结构体嵌套初始化struct Node n2 = &#123;6, &#123;4,5,6&#125;, NULL&#125;;//结构体嵌套初始化\n\ntypedef重定义结构体由于每次定义结构体变量，我们总是需要写那么一长串来定义变量，比较麻烦，这时我们就可以使用typedef重定义结构体：\ntypedef struct Student&#123;    char name[20];    int age;&#125;Stu;\t//将 struct Student 重定义为 Stu//以后创建变量，就可以写成：Stu s1;Stu s2;\n\n\n\n结构体的自引用顾名思义，既然我们可以使用声明一个结构体后可以使用结构体类型来创建变量，那么是否可以在结构体内部使自己的类型来创建一个自己的变量呢？答案是可以的，但是并不能直接创建\n实例1：\n//比如这里想来一个套娃：struct son&#123;\tchar name[20];\tstruct son next_son;&#125;;struct son s1;\n\n这时我们创建一个变量s1，他的内部会有一个名字，并有他的儿子,而创建了他的儿子之后里面又生成了儿子的儿子的儿子…….最终无穷无尽递归下去，所以不能这么写。即便是可以，如果计算**sizeof(struct son)**会算出什么来呢？我们不得而知。\n因此正确的方式是：\nstruct son&#123;    char name[20];    struct son* next_son;&#125;struct son s1;\n\n在创建一个变量s1后，s1会有自己的名字，而s1内部的指针不用时可以置为空，在使用时就可以指向下一个儿子\nstruct son&#123;    char name[20];    struct son* next_son; &#125;s1,s2;s1.next_son = &amp;s2;//存放s2的地址,当然我们一般不会这么写，下面会有别的写法s2.next_son = NULL;\n\n而之后数据结构中的链表，就需要使用这种方式：\nstruct Node&#123;    int data;    struct Node* next;&#125;;\n\n注意：一个错误的写法：\ntypedef struct &#123;    int data;    Node* next; // 错误！此时编译器尚未识别 &quot;Node&quot; 类型&#125; Node;\n\n在结构体定义内部，成员 Node* next 试图使用 Node 作为类型名，但此时 typedef 尚未完成对匿名结构体类型的重命名。编译器在解析结构体成员时，Node 还未被定义，因此会报错：unknown type name &#39;Node&#39;。\n因此正确的方式是：\ntypedef struct Node &#123;    int data;    struct Node* next;&#125; Node;\n\n结构体成员变量的访问使用结构体创建变量后，要访问变量内的数据要用到两个操作符：.和-&gt;普通变量使用.来访问成员变量，指针类型使用-&gt;来访问成员变量。例如：（malloc函数可以看这篇C语言动态内存管理)\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Student &#123;    char name[20];    int age;    int id;&#125; Student;int main() &#123;    Student s1 = &#123;&quot;张三&quot;, 18, 123456&#125;;    //普通类型访问成员变量    Student s2;    strcpy(s2.name, &quot;李四&quot;);//将&quot;李四&quot;拷贝给s2.name    s2.age = 18;    s2.id = 654321;    printf(&quot;%s-%d-%d\\n&quot;, s1.name, s1.age, s1.id);    printf(&quot;%s-%d-%d\\n&quot;, s2.name, s2.age, s2.id);    \t//指针类型访问成员变量    Student* s3 = (Student*)malloc(sizeof(Student));    strcpy(s3-&gt;name, &quot;小明&quot;);     s3-&gt;age = 18;    s3-&gt;id = 1345678;    printf(&quot;%s-%d-%d\\n&quot;, s3-&gt;name, s3-&gt;age, s3-&gt;id);    free(s3);    s3 = NULL;    return 0;&#125;\n\n结构体的大小我们熟知char类型变量占1个字节，int类型变量占4个字节，long long类型变量占8个字节，那么我们自己定义的结构体类型占多大的空间呢？\n这里运行\nstruct S1&#123;\tint i;    char c1;    char c2;&#125;;printf(&quot;%d\\n&quot;, sizeof(struct S1));\n\nstruct S2&#123;    char c1;    int i;    char c2;&#125;;printf(&quot;%d\\n&quot;, sizeof(struct S2));\n\n明明成员变量的类型都一样，运行完后我们得到了两个不同的结果：\n\n这就涉及到结构体内存对齐：\n基本对齐规则：\n首成员对齐\n结构体的第一个成员从偏移量0的地址开始存放\n\n成员偏移对齐\n其他成员变量与一个对齐数的整数倍的地址处对齐（其中对齐数为编译器默认对齐数与该成员大小的较小值）即：\n对齐数&#x3D;min(编译器默认对齐数，该成员大小)（Linux下gcc的默认对齐数为4，Windows下msvs默认对齐数为8，这些均可自己设置）\n\n每个成员都有自己的对齐数，结构体的总大小为最大对齐数的整数倍\n\n如果结构体嵌套了结构体，嵌套的结构体对齐到内部最大成员对齐数的整数倍处，结构体的整\n体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍\n\n\n就比如：(预编译指令#pragma pack()可以设置默认对齐数)这里以4为例\n#pragma pack(4)//设置默认对齐数为4struct S1&#123;\tint i;\t\t//i占4个字节，第一个成员在0处放置      char c1;\t//c1占1个字节，1&lt;4,放在直接放在i的后面    char c2;\t//同上&#125;;//上面 4+1+1=6printf(&quot;%d\\n&quot;, sizeof(struct S1));//最终为最大对齐数的整数倍也就是4的整数倍:8\n\n\n第二种：\nstruct S2&#123;    char c1; //第一个位置    int i;\t//4=4,与4的倍数处即4处对齐    char c2;//1&lt;4,前面已经排到的7的位置，因此放到8处&#125;;//4+4+1=9printf(&quot;%d\\n&quot;, sizeof(struct S2));//最终应为最大对齐数（这里面是4）的整数倍：12\n\n\n同理下方：\nstruct S3&#123; double d;\t//位置0处，后面占8个字节（0~7） char c;\t//位置8处，占一个字节(8) int i;\t\t//位置12处，占4个字节(12~15)&#125;;//8+4+4=16,恰好为4的倍数printf(&quot;%d\\n&quot;, sizeof(struct S3));//最终为16//这里由于我用的编译器是gcc，double的默认对齐数是4，vs下默认对齐数是8//结构体嵌套问题struct S4&#123; char c1;   //位置0处，1个字节(0~3) struct S3 s3;//位置4处，内部最大对齐数为4，4=4，s3共占16个字节(4~19) double d;//4=4,位置20处(20~27)&#125;;//4+16+8=28,最终应为4的倍数：28printf(&quot;%d\\n&quot;, sizeof(struct S4));\n\n所以下面所有运行结果：\n#pragma pack(4);#include &lt;stdio.h&gt;int main() &#123;struct S1&#123; int i; char c1; char c2;&#125;;printf(&quot;%d\\n&quot;, sizeof(struct S1));struct S2&#123; char c1;  int i; char c2;&#125;;printf(&quot;%d\\n&quot;, sizeof(struct S2));struct S3&#123; double d; char c; int i;&#125;;printf(&quot;%d\\n&quot;, sizeof(struct S3));struct S4&#123; char c1; struct S3 s3; double d;&#125;;printf(&quot;%d\\n&quot;, sizeof(struct S4));&#125;\n\n\n如果把默认对齐数修改成1，就可以相当于以成员变量来计算大小，此时输出结果：\n\n因此我们得出结论：在设计结构体的时候，应尽量让占用空间小的成员集中在一起，才能更节省空间。\n"},{"title":"git使用","url":"/2025/03/27/git%E4%BD%BF%E7%94%A8/","content":"不管是写代码项目，还是实验报告，我们总是要遇到这样的情况：为了写出最完美的版本，我们要更改多次，但是含怕更改后出现问题且无法恢复，就必须复制出一个副本,于是就有了这样的情况：\n\n“test_1”\n“test_2”\n“test_3”\n…最终版\n…究极版\n……\n\n于是写着写着,自己都忘记了每个版本都干了什么了，只能再一个一个去看,找了个看着还凑合的就提交上去了……\n不过，那些程序员大佬可没这个闲工夫看来看去。有了这样的需求，版本控制器应运而生，通过版本控制器，我们可以随时管理回溯到一个文件的各个版本，也方便多个人共同作业。\n当下最主流的一款版本控制器叫Git，当然我们也听说过大名鼎鼎的Github就是一个由git发展而来的远程管理的网站，方便一些开源以及团队协同办公。 \nGit安装Git基本操作配置Git安装完Git后的第一个任务就是配置你的用户名称和邮箱地址（在团队协作中，我们需要知道是做了更改，并且可以通过什么方式联系到他）。配置方法：\ngit config [--global] user.name &quot;Your Name&quot; git config [--global] user.email &quot;email@example.com&quot;#  Your Name 为你的昵称 #  email@example.com 为你的邮箱 \n\n配置完可以使用下面命令查看配置的信息：\ngit config -l\n\n也可以使用下面命令删除配置信息：\ngit config [--global] --unset user.namegit config [--global] --unset user.email\n\n上方**[–global]**是一个可选项，使用这个选项表明我们以后管理所有的文件都使用这个名字，如果想要在不同的仓库中使用不同的名字，可以去掉这个选项，然后在某个仓库内部执行命令。\n创建本地仓库现实中我们可以使用仓库来对物品进行管理（贴标签，做记录等），同理我们想要对文件进行管理，也要建立一个仓库，在这里我们的仓库实际上就是文件夹，不同的项目可以对应创建不同的仓库（即文件夹），Git通过追踪仓库内文件的变化实现版本控制。以下是两种创建本地仓库的方法：\n\n第一种：直接创建并初始化仓库\n在终端内直接执行：\ngit init my-repo   #my-repo为你的仓库名，可以自己取名\n\n\n作用：在当前目录下自动创建名为 my-repo 的文件夹，并初始化Git仓库。\n注意：  \n仓库名称建议使用英文、数字或连字符（如 my-project），避免空格或特殊字符。\n执行后会在 my-repo 目录下生成隐藏的 .git 子目录，存放Git的版本控制数据。\n\n\n\n\n第二种：手动创建文件夹后初始化\n\n先创建一个目录：\n\nmkdir my-repo\t# 创建文件夹cd my-repo\t\t# 进入该目录\n\n\n初始化仓库：\n\ngit init\n\n注意：  \n\n此方法适用于已有项目目录的初始化。\n初始化后需确保当前目录下生成 .git 文件夹，可通过 ls -a（Linux&#x2F;macOS）或显示隐藏文件（Windows）查看。\n\n\n注意：仓库目录中包含 .git 隐藏文件夹，该目录由Git自动管理，不要手动修改内部文件，否则可能导致版本信息损坏。进入.git文件夹下，可以看到里面的文件（看看就行[dog]）\n.git├── branches├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── info│   └── exclude├── objects│   ├── info│   └── pack└── refs    ├── heads    └── tags\n\n\n\n\n工作区、暂存区和版本库的概念\n工作区：就是我们刚刚创建的仓库目录，也是我们以后要放代码或其他文件的目录。\n暂存区：\n\n"},{"title":"Hello World","url":"/1970/01/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"python语法基础","url":"/2025/03/21/python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/","content":"python是一种面向对象的解释型高级编程语言\n强类型的动态脚本语言\n\n\n\n\nprint函数print(&quot;hhhh&quot;,&quot;hhhhh&quot;) \t#输出：hhhh hhhhh#sep 用来间隔多个值,不写默认是空格print(&quot;hhhh&quot;,&quot;hhhhh&quot;,sep=&#x27;,&#x27;)\t#输出：hhhh,hhhhh#end 设置结尾，不写默认是换行\\nprint(&quot;hello&quot;,end=&quot; &quot;)print(&quot;world&quot;)\n\n变量，标识符a=1b=2c=a+b\n\n标识符：定义的变量名，不能用关键字（if,else,等）\n数值类型整型：int\t1，2，3\n浮点数：float\t1.1，1.3\n布尔型：bool\tTrue(1)&#x2F;False(0)\n复数：complex\t z&#x3D;a+bj\n查看类型：\nprint(type(...))\n\n字符串str   “”或’‘\nst = &quot;qqq&quot;s = &#x27;www&#x27;name = &quot;&quot;&quot;hhhhhhhlllllljjjjjj&quot;&quot;&quot;# 多行注释也是引号print(name)\n\n字符串编码转换：\na=&quot;hello&quot;a1=a.encode(&quot;utf-8&quot;)print(&quot;编码前a:&quot;,a)print(&quot;编码后a1:&quot;,a1)print(type(a1))a2 = a1.decode()#解码print(&quot;解码后a2:&quot;,a2)print(type(a2))\n\n字符串常见操作\n下标&#x2F;索引字符串名[下标]\n从左往右数：下标从0开始\n从右往左数：下标从-1开始\n切片[起始,结束,步长]\t步长也要遵循正负号方向\n还是包前不包后原则\n[x: ]\tx到结尾\n[ :y]\t开头到y的前一个\n字符串的查找、修改、判断\n\n格式化输出1.占位符#占位符name = (&quot;qmtt&quot;)print(&quot;我的名字：%s&quot; % name)age = 19print(&quot;我的名字:%s,我的年龄：%d&quot; % (name, age))# 控制长度print(&quot;%4d&quot; % age)# 控制输出位数前面用0补全print(&quot;%04d&quot; % age)#浮点数a = 1.12345691022print(&quot;%f&quot; % a) #默认输出6位小数，多出来了四舍五入# 设置小数位数,遵循四舍五入print(&quot;%.10f&quot; % a)# %%输出一个%print(&quot;我是%%的%%&quot; %())\n\n2.f格式化# 格式：f&quot;&#123;表达式&#125;&quot;name = &quot;qmtt&quot;age = 19print(f&quot;名字：&#123;name&#125;,年龄：&#123;age&#125;&quot;)\n\n运算符算术运算符\n\n注意：\n使用&#x2F;商一定是浮点数且除数不能为0\n使用算术运算符,若使用浮点数，结果也用浮点数表示\n赋值运算符a=10#a=a+1a+=1a-=1\n\n输入函数input输入的为字符串类型（str）\n#inputname = input(&quot;请输入姓名：&quot;)print(&quot;Hello, &quot; + name)print(name)\n\n转义字符\nage = input(&quot;What is your age?&quot;)age = int(age)if age &gt;= 18:    print(&quot;成年&quot;)\n\n补充：\nprint(r&quot;as\\\\\\\\dfg&quot;)##原生字符串，取消转义\n\nif判断基本判断age = input(&quot;What is your age?&quot;)age = int(age)if age &gt;= 18:    print(&quot;成年&quot;)\n\n其他\n循环语句while循环\nfor循环#for 临时变量 in 可迭代对象：#字符串就是可迭代对象# 计数：# range()用于记录循环次数，相当于一个计数器# range(start,stop,step)   左闭右开[ )for i in range(1,10):    print(i)\n\nbreak：结束循环\ncontinue：跳过当此循环，进如下一次循环\n列表\n列表操作：增删查改\n添加元素li = [1,2,3,4,&#x27;a&#x27;,&#x27;d&#x27;]print(li,type(li))print(li[0],type(li[0])) #有序，可以通过下标访问print(li[0:3]) #切片操作#列表也是可迭代对象，可以for循环遍历取值#列表的常见操作：增删查改#1.添加元素li1 = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;]li1.append(&#x27;four&#x27;)  #append 整体添加li1.extend(&#x27;five&#x27;)  #分散添加，将元素逐个添加，且里面只能填写可迭代对象li1.insert(1,&#x27;six&#x27;) #指定位置插入元素，有元素就会后移print(li1)\n\n修改元素下标修改\n查找元素和字符串一样\nname_list = [&#x27;zhangsan&#x27;,&#x27;lisi&#x27;,&#x27;wangwu&#x27;]while True:    name = input(&#x27;请输入您的名字：&#x27;)    if name in name_list:        print(&#x27;已存在，请重新输入&#x27;)    else:        name_list.append(name)        print(f&#x27;成功添加&#123;name&#125;&#x27;)        print(name_list)        break\n\n删除元素li = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]#del li   #删除列表del li[0] #删除元素a = li.pop()li.remove(a) #删除指定元素，重复的话删除第一个print(li)print(a)\n\n排序li = [4,1,5,3,7,2]li.sort()   #从小到大排序li.sort(reverse=True) #从大到小li.reverse() #逆置print(li)\n\n列表推导式# 列表推导式# 格式1：[表达式 for 变量 in 列表]# in后面不仅可以放列表，还可以放range(),可迭代对象li = [1,2,3,4,5,6,][print(i*2) for i in li] #前面的i是表达式li1=[]# for i in range(1,6):#     print(i)#     li1.append(i)# print(li1)# 使用列表推导式更简单的写法[li1.append(i) for i in range(10)]print(li1)#格式2：添加一种条件# [表达式 for 变量 in 列表 if 条件]# 把奇数放到列表里面li2 = [][li2.append(i) for i in range(10) if i%2 != 0]print(li2)\n\n列表嵌套列表里面嵌套列表\nli = [1,2,3,[1,2,3]]print(li[3])print(li[3][1])\n\n元组# 元组tuple# 基本格式：元组名 = （元素1，元素2，元素3...）# 小括号tua = (1,2,3,4,5,&#x27;a&#x27;,&#x27;c&#x27;,[1,2,3])tub = (1,) #只有一个元素的时候，末尾一定要加上‘，’，否则会变成这个元素的数据类型print(type(tua))print(tua)# 元组与列表的区别# 1.元组若只有一个元素，末尾必须加‘,’# 2.元组只支持查询操作，不支持增删改tua1 = (1,2,1,3,4,5,&#x27;a&#x27;,&#x27;c&#x27;,[1,2,3])# tua1[0]= 2  # 会报错print(tua1[0])# count(),len(),index(),切片用法和列表相同print(tua1.count(1))print(len(tua1))# # 应用场景# # 格式化输出，后面的（）本质上就是一个元组# # 数据不能被修改的时候name = &quot;qmtt&quot;age = 18info = (name,age)print(&quot;姓名是%s,年龄是%d&quot; % (name,age))print(&quot;姓名是%s,年龄是%d&quot;% info)\n\n字典基本格式# 字典# 基本格式：字典名 = &#123;键1:值1,键2:值2,...&#125;dic = &#123;&#x27;name&#x27;:&#x27;qmtt&#x27;,&#x27;age&#x27;:19&#125;print(type(dic))dic1 = &#123;&#x27;name&#x27;:&#x27;qmtt&#x27;,&#x27;name&#x27;:&#x27;qwer&#x27;&#125;print(dic1) # 第一个会被第二个覆盖#字典中的键具有唯一性，但是值可以重复\n\n常见操作查找元素# 常见操作# 1.查看元素# 变量名[键名]dic = &#123;&#x27;name&#x27;:&#x27;qmtt&#x27;, &#x27;age&#x27;:66&#125;print(dic[&#x27;name&#x27;]) #字典中不能根据下标来访问元素，键名不报错会报错print(dic[&#x27;age&#x27;])# 变量名.get(键名)print(dic.get(&#x27;age&#x27;)) # 若键名不存在，默认返回Noneprint(dic.get(&#x27;hh&#x27;, &#x27;不存在&#x27;))# 若不存在，返回自己设置的默认值\n\n修改元素# 修改元素# 变量名[键名] = 值dic = &#123;&#x27;name&#x27;:&#x27;qmtt&#x27;,&#x27;age&#x27;:19&#125;dic[&#x27;age&#x27;] = 99print(dic)# 键名存在就会修改，不存在就会新增\n\n删除元素# 删除元素#  1.del# del 字典名 删除整个字典# del 字典名[键名] 键值对不存在就会报错dic = &#123;&#x27;name&#x27;: &#x27;qmtt&#x27;, &#x27;age&#x27;: 19&#125;del dic[&#x27;age&#x27;]# 2.clear 清空字典里的东西，但是保留字典dic.clear()print(dic)# 3.popdic = &#123;&#x27;name&#x27;: &#x27;qmtt&#x27;, &#x27;age&#x27;: 19&#125;dic.pop(&#x27;age&#x27;)dic.popitem()#可以指定，默认删除最后一个元素print(dic）\n\n常见操作2\n# 字典常见操作2dic = &#123;&#x27;name&#x27;:&#x27;qmtt&#x27;,&#x27;age&#x27;:20&#125;print(len(dic))  # len求长度print(dic.keys()) # 取出所有键名# for循环取出键名for i in dic.keys():    print(i)print(dic.values()) # 返回所有值print(dic.items()) # 返回所有键值对,以元组的形式print(dic)# 字典的应用场景:# 用键值对,存储描述一个物体的相关信息\n\n集合# 集合 set# 基本格式:集合名= &#123;元素1,元素2,元素3&#125;# 集合具有无序性s = &#123;&#125; # 定义空字典s1 = set() # 定义空集合print(s1,type(s1))s2 = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;a&#x27;,&#x27;d&#x27;&#125;print(s2) #每次运行的结果不一样s3 = &#123;1,2,3,4,5&#125;print(s3) #每次运行的结果一样# 原因:# 集合无序的设计方式涉及哈希表print(hash(&#x27;a&#x27;)) #print(hash(&#x27;b&#x27;))print(hash(&#x27;c&#x27;))# 每一次运行结果都不一样# 利用无序性,不能修改集合里的值# 集合具有唯一性,可以自动去重\n\n常见操作\n交集:&amp;\n并集:|\n类型转换\n深浅拷贝浅拷贝# 深浅拷贝# # 赋值,两个对象会一起发生变化# li = [1,2,3,4]# print(li)# li2 = li #将li赋值给li2# print(li2)# li.append(5)# print(li)# print(li2) #会发现这里li和li2都发生了变化# 浅拷贝(数据半共享)# 会创建新的对象,拷贝第一层的数据,嵌套层会指向原来的内存地址import copy # 导入copy模块li = [1,2,3,[4,5,6]] #定义一个嵌套列表li2 = copy.copy(li)print(li)print(li2)# 查看内存地址print(id(li))print(id(li2))# 内存地址不一样,说明不是同一个对象li[3].append(7)print(li)print(li2) #会发现还是被修改了# 外层的地址不同,但是内层的地址相同# 优点:拷贝速度快,占用空间少,拷贝效率高# 深拷贝:数据完全不共享# 外层的对象和内部的元素全部拷贝了一遍\n\n深拷贝# 深拷贝:数据完全不共享# 外层的对象和内部的元素全部拷贝了一遍import copyli = [1,2,3,[4,5,6]]li2 = copy.deepcopy(li)\n\n可变对象存储空间保存的数据允许被修改，这种类型就是可变类型\n常见可变类型：\n\n列表 list\n字典 dict\n集合 set\n\n函数基础语法# 函数# def 函数名()#     函数体def login():    print(&quot;这是登录函数&quot;)    return &quot;登录函数&quot;,1,2print(login()) #可以返回多个值，以元组的形式返回# 没有返回值，返回none# return 表示函数结束def add(x,y):    return x+yprint(add(1,2))\n\n函数参数# 1、必备参数（位置参数）# 含义：传递和定义参数的顺序及个数必须一致# 格式： def func(a,b)# 默认参数# 含义：为参数提供默认值，调用函数时可以不传该默认参数的值# 所有位置参数必须出现在默认参数前，包括函数定义和调用# 格式：def func(a,b,c=1)# 可变参数# 传入的值的数量是可以改变的，可以传入多个，也可以不传# 格式：def func(*args)def func(*args):    print(args)    print(type(args))func(1,2,3,4) # 以元组的形式接收# 关键字参数# 格式： def func(**kwargs)def fund(**kwargs):    print(kwargs)    print(type(kwargs)) # 以字典的形式传值fund(name = &#x27;hhhh&#x27;,age=999)# 作用：可以拓展函数的功能\n\n作用域# 作用域：# 含义：变量生效的范围# 全局变量：函数外部的变量，在整个文件中都是有效的# 函数内部使用变量，会先从函数内部找，有的话直接使用，没有的话会到函数外面找# 局部变量：函数内部定义的变量，从定义位置到函数结束位置有效# 只能在被定义的函数中使用，外部不能使用# 在函数内部被定义，函数调用完成后就销毁# 函数内部无法修改全局变量的值，更改完全局变量的值并不会改变# 若要在函数内部修改全局变量的值，要用到关键字globala = 10b = 20def func():    a = 100    global b    b = 200func()print(a,b)\n\n# nonlocal# 用来声明外层的局部变量，只能在嵌套函数中使用，# 在外部函数先进行声明，内部函数进行nonlocal声明a = 10def outer():    # 外函数    a = 5       # 局部变量    def inner():    #内函数        nonlocal a        a = 20 # 同时对上一层进行修改（上上层不会被修改）        print(&#x27;内函数中a的值:&#x27;,a)    inner()    print(&#x27;外函数中a的值:&#x27;,a)outer()print(a)\n\n# 匿名函数(参数的使用和上面一样)# 语法：# 函数名 = lambda 形参 : 返回值# 调用: 结果 = 函数名(实参)## def add(a,b):#     return a+badd = lambda a,b: a+bprint(add(1,2))# 如果有多个返回值,仍是元组的形式\n\nlambdia结合if判断# lambda结合if判断# a = 5# b = 8# 三目运算符：# 为真结果 if 条件 else 为假结果# print(&quot;a比b小&quot;) if a&lt;b else print(&quot;a比b大&quot;)# 将三目运算当成一个返回值comp = lambda a,b : &quot;a比b小&quot; if a&lt;b else &quot;a比b大&quot;print(comp(3,2))\n\n内置函数# 内置函数import builtinsprint(dir(builtins))# 大写字母开头一般是内置常量名，小写字母开头一般是内置函数名# 返回绝对值print(abs(-10))# 求和print(sum([1,2,3])) # 必须是可迭代对象print(sum((3,4,5))) # 字符串也不可以print(sum(&#123;1,2,3,4,5.1&#125;)) # 运算时只要有一个浮点数，结果就也是浮点数# 求最大最小值print(min(2,4,5,6,7,))print(max(2,4,5,6,7,))# 根据绝对值来求最值print(max(2,4,5,6,-7,key=abs))# zip():将可迭代对象作为参数，将对象中对应的元素打包成一个个元组li1 = [1,2,3]li2 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]print(zip(li1,li2)) # 元素个数不一致，按长度最短的来返回for i in zip(li1,li2):    print(i)    print(type(i))print(list(zip(li1,li2))) # 还是两个必须是可迭代对象# map():可以对可迭代对象中每一个元素进行映射，分别去执行# map(func,iter1) func:自己定义的函数，iter1:要放进去的可迭代对象# 即：对象中的每一个函数都会传入函数执行li = [1,2,3,4]def funa(x):    return x*2mp = map(funa,li) # 只需写函数名，不用写()print(list(mp)) #取出方法和上面一样# reduce()# 先把对象中的两个元素取出，计算出一个值然后保存着，# 接下来把这个值跟第三个元素进行计算from functools import reduce# reduce(function,sequence)# function:函数且必须能接收两个参数，# sequence：序列必须是可迭代对象li3 = [2,3,5,6]def add(x,y):    return x+yprint(reduce(add, li3))\n\n拆包# 拆包：对于函数中的多个返回数据，去掉元组、列表或字典，直接从里面获取数据的过程tua = (1,3,4,5)print(tua)print(tua[0])# 方法一：要求元组内的个数与接收的变量个数相同，# 对象内有多少个数据就定义多少个变量接收a,b,c,d = tuaprint(a,b,c,d)# 方法二：a,*b = tuaprint(a,b)# 一般在函数调用时使用def funa(a,b,*args):    print(a,b)    print(args,type(args))funa(1,2,3,4,5,6,7)arg = (1,2,3,4,5,6,7)funa(*arg)\n\n\n\n异常常见异常：\n\n#异常# try:# finally:#程序中出现了问题# 检测到异常后，解释器就无法再执行了# print(a) NameError: name &#x27;a&#x27; is not defined# print(&#x27;a&#x27;)# a = 10# print(a) #这样就正常了# 抛出异常：rise# 1.创建一个Exception(&#x27;xxx&#x27;)对象，xxx异常提示信息# 2.raise抛出这个对象（异常对象）# raise Exception(&quot;出现了错误&quot;)# 也可以来写成一个函数来执行：# def funa():#     print(&#x27;funa&#x27;)#     raise Exception(&#x27;funa&#x27;)#     # 执行完raise后，后面的代码不会继续往后执行## funa()def login():    pwd = input(&quot;请输入密码:&quot;)    if len(pwd) &gt;= 6:        return &quot;密码输入成功&quot;    else:        a = Exception(&quot;长度不足6位&quot;)        raise a# print(login())try:    print(login())except Exception as e:    print(e)# 捕获异常是为了检测到异常时代码还能继续允许，即程序不会终止\n\n模块一个py文件就是一个模块，即导入一个模块本质就是执行一个py文件\n分类：\n1.内置模块：random，time，os，login\n2.第三方模块（pip）\n3.自定义模块：即自己在项目中自定义的模块\n命名要注意，防止和内置模块冲突\n# 导入模块# import 模块名# 调用：# 模块名.功能名# 可以一个import导入多个模块，但最好是一个import mytestmytest.funa()# 方式2：# from 模块名 import ....# 这时直接就可以使用功能，没有导入的就不能使用from mytest import funafuna()# 方式3# from ... import *# 把模块中所有内容全部导入# 不建议，因为有时候命名冲突会造成错误\n\n起别名# as起别名import mytest as mtmt.funa()# 给功能起别名# from 模块名 import 功能 as 别名# 导入多个功能，用逗号隔开\n\n# 第一个py文件# 内置全局变量# __name__# 语法：# if __name__ == &quot;__main__&quot;:# 作用：# 用来控制py文件在不同的应用场景执行不同的逻辑# __name__# 1.文件在当前程序执行（即自己执行自己）：__name__==&quot;__main__&quot;# 被当作模块导入时，下面的代码不会被显示出来import pytest2pytest2.test()\n\n# 第二个py文件print(&quot;会显示的内容&quot;)def test():    print(&quot;test&quot;)if __name__ == &quot;__main__&quot;:# 被当作模块导入时，下面的代码不会被显示出来    print(&quot;这是pytest2作为模块不会显示的内容&quot;)\n\n包含义：就是项目结构中的文件夹/目录# 与普通文件夹的区别:包是含有__init__.py的文件夹# 作用：将有联系的模块放到同一个文件夹下，有效避免模块名称冲突，让结构更清晰# 新建包：右键项目名-&gt;new-&gt;Python package# import 导入包时，首先执行__init__.py文件的代码# 不建议在__init__文件中写大量代码# 导包方式1：# import pack# 方式2：# from pacn import .py 文件\n\n# 包# 含义：就是项目结构中的文件夹/目录# 与普通文件夹的区别:包是含有__init__.py的文件夹## 作用：将有联系的模块放到同一个文件夹下，有效避免模块名称冲突，让结构更清晰# 新建包：右键项目名-&gt;new-&gt;Python package# import 导入包时，首先执行__init__.py文件的代码# 不建议在__init__文件中写大量代码# 导包方式1：# import pack# 方式2：# from pacn import .py 文件# __all__:本质上是一个列表，列表里面的元素就代表要导入的模块# 作用：可以控制要引入的东西# 包的本质是一个模块，包里还可以包含包\n\n递归函数# 递归函数# 条件：# 1.必须有一个明确的结束条件：递归出口# 2.没进行一次更深一层的递归，问题规模相比上次递归都要有所减少# 3.相邻两次重复之间有紧密联系# # 普通函数来写# def add():#     s = 0#     for i in range(1,101):#         print(i)#         s+=i#     print(s)# add()# 递归函数def add2(n):    if n == 1:        return 1    return n+add2(n-1)print(add2(100))\n\n# 递归实现斐波那契数列def Fei(n):    if n &lt;= 2:        return 1    return Fei(n-1)+Fei(n-2)m = int(input())li = list()for i in range(1,m+1):    li.append(Fei(i))print(li)\n\n递归的缺点：耗内存\n闭包# 闭包# 条件：# 1.函数嵌套# 2.内层函数使用外层函数的局部变量# 3.外层函数的返回值是内层函数的函数名def outer():#外层函数    n =10    def inner():        print(n)    return innerprint(outer()) # 会打印内函数的内存地址outer()() # 第一种写法# 第二种写法：ot = outer() # 调用外函数ot()\n\n# 函数引用：def funa():    print(123) # 函数名里面保存了函数所在位置的引用print(funa)# id(): 判断两个变量是否是同一个值的引用a = 1print(a)print(id(a))a = 2       # 修改a,生成了新的值，重新赋值给变量aprint(id(a)) # 会发现地址不一样了print(id(2))print(id(3))# 内存地址发生了变化，因为值也发生了变化def test1(): # test1也是一个函数名，里面存了这个函数所在位置的引用    print(&quot;test1函数&quot;)print(test1) # 内存地址(引用)te = test1te() # 通过引用调用函数# 这就是前面ot加小括号的原因\n\ndef outer(m): # 外函数，m是形参，也是外函数的局部变量    n = 10    def inner(o=0):        print(&quot;计算结果:&quot;,m+n+o)    return inner # 返回函数名，而不是inner()的原因是inner函数里面的参数较多或者说受到限制时，写法不太规范# outer(10)# print(outer(10))outer(20)()ot = outer(20)ot()\n\n# 每次开启内函数都在使用同一份闭包函数def outer(m):    print(&quot;outer()函数中的值:&quot;,m)    def inner(n):        print(&quot;inner()函数中的值:&quot;,n)        return m+n # 在inner函数中返回m+n的值    return innerot = outer(10) # 调用外函数# ot(20) # 调用内函数print(ot(20))print(ot(30))# 外函数并不会消亡，而是一直在内存中有一个实例，每次调用内函数就可以引用外函数的局部变量\n\n装饰器# 装饰器# 在不修改代码的情况下给函数增加新的功能# def test02():#     print(&quot;学号：&quot;)# def test(fn):#     print(&quot;姓名：&quot;)#     fn() # 调用要传入的函数# test(test02)# 使用装饰器# 条件：# 1.不修改原程序或函数的代码# 2.不改变函数或程序的调用方法\n\n# 标准版装饰器# 被装饰的函数def test01():    print(&quot;姓名：&quot;)def test02():    print(&quot;性别&quot;)def outer(fn):    # 外层函数，fn是形参，但是往里面传入的是被装饰的函数名：test01    # 既包含原有功能，又包含新功能    def inner(): # 内层函数        # 执行被装饰的函数        print(&quot;学号：&quot;)        fn()    return inner# print(outer(test01()))# outer(test01())ot = outer(test02)  # 调用外函数ot()                 # 调用内函数# 装饰器的原理就是将原有的函数名重新定义为以原函数为参数的闭包\n\n# 语法糖# 格式：@装饰器名称def outer(fn):    def inner():        print(&quot;学号：&quot;)        fn()    return inner@outer # 放在被装饰的函数前，顶格写def test01():    print(&quot;姓名：&quot;)test01()\n\n# 被装饰的函数有参数def outer(fn):    def inner(x): # 内函数，name是内函数的参数        print(f&quot;&#123;x&#125;是inner函数中的参数&quot;)        fn(x)    return inner@outerdef func(x):    print(&quot;这是被装饰的函数&quot;)func(2)# 或者ot = outer(func)ot(3)\n\n"},{"title":"test","url":"/2025/04/20/test/","content":""},{"title":"动态内存管理","url":"/2025/03/16/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"在C语言中，我们已经知道有两种方式来获取内存空间：定义变量和创建数组\nint x = 10;//在栈空间获取4个字节来存储10int arry[10];//在栈区获取10个字节的连续空间\n\n他们特点很明显：内存空间都是固定的，数组也需要在声明的时候就指定长度（但c99中支持了数组定义时[]内写变量）。\n但是实际情况是：在有些情况下只有程序运行的时候我们才知道它需要多大的内存，而那时原先申请固定内存已经不满足了。这个时候就需要来动态开辟内存。\nC语言中共有三个申请内存空间的函数：malloc ， calloc ，realloc，也提供了一个将空间还给内存的函数：free。这四个函数都在头文件stdlib.h中声明。\nmalloc和freemalloc函数的原型：\nvoid* malloc(size_t size);\n\nsize_t为无符号整形，即在内存中申请一块连续可用的大小为size的空间（大小为字节）， 若申请并开辟成功，则返回值是指向这块空间起始位置的指针，类型为void* 需要我们自己来决定申请的类型。若申请失败，则返回NULL，因此使用mallloc函数时需要做检查。如果参数 size 为0，malloc的行为是标准是未定义的，出现的情况取决于你使用编译器。\n例如申请一个16字节的空间\nint *p = (int*)malloc(4*sizeof(int));//或int *p = malloc(4*sizeof(int));//在c语言中void*可以隐式类型转换，这里推荐第一种显式类型转换，可提高代码可读性\n\n这样p就指向了一个16字节的空间:\n\n有借有换，再借不难。我们向内存申请了空间，当我们不需要的时候，就需要将空间还给内存，C语言提供了free函数来对内存进行释放和回收，否则会有内存泄露的风险。函数原型：\nvoid free (void* ptr);\n\nfree用来释放我们自己动态开辟的内存，不能释放非动态开辟的。\n举例：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    int n = 0;    scanf(&quot;%d&quot;,&amp;n);\tint* p = NULL;    p = (int*)malloc(n*sizeof(int));//申请4*n个字节的空间，即n个整形    if(p!=NULL)\t\t//判断是否申请失败    &#123;        for(int i=0;i&lt;n;i++)        &#123;            *(p+i)=0;\t//int*型指针，每次+1跳过4个字节，将n个整形全部赋值为0                //其实这里对于整形指针p指向空间的访问既可以写:*(p+i),更直观的写法是:p[i]两种写法是等价的，就像数组一样            \t//其他类型的指针也是一样的，比如char*指针*(p+1)一次跳过1个字节            \t//long long一次8个字节        &#125;    &#125;    //在使用完以后，就需要释放掉p所指向的空间    free(p);    p=NULL;//这里要注意的是我们只是将空间还给了内存，p对该区域不再有访问权限，但是它仍指向了这个位置即现在p指向了非法的位置，成了野指针，因此需要置空。    return 0;&#125;\n\ncalloccalloc函数原型：\nvoid* calloc(size_t num,size_t size);\n\ncalloc函数的功能:是为num（元素个数）个大小为size（一个元素所占的字节数）的函数申请一块空间，并且把空间内的每个字节都初始化为0\ncalloc与malloc函数区别就是将每个字节都置为0且calloc函数可自定义每个元素长度，calloc更适合初始化大型数据结构，比如创建数组或结构体\n举例：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    int* p = (int*)calloc(4,sizeof(int));//申请4*4个整形的空间，即4个整形    /*    if(p!= NULL)    &#123;        //这里直接就可以使用，无需自己初始化。    &#125;    */    //或者另一种判断是否为空的方法：    if(p==NULL)    &#123;        exit(-1);//中间可以填任意非0数字，在申请内存失败时就可以终止程序并终止程序    &#125;    //.....使用空间        //释放空间   \tfree(p);    p=NULL;    return 0;&#125;\n\nreallocrealloc函数可以对我们申请到的空间动态的调整。函数原型：\nvoid* realloc(void* ptr,size_t size);\n\nptr为我们要调整内存的地址，size是重新调整之后的大小。返回值仍然是是调整之后的内存起始位置。\n当我们缩小空间时，会直接在原空间后面切除。如果后面有数据也会直接丢失。\nint* p = (int*)malloc(10);p = realloc(p,5);//由10个字节缩减为5个字节\n\n\n当我们放大空间时就会有问题：\n我们知道申请的空间在内存中是连续的，所以在使用realloc函数拓展内存时我们会遇到两种情况：\n第一种是后面的内存够用：会直接往后延长\n\n第二种是后面的内存不够用：\n\n此时realloc会在堆区找一块新的连续空间，将原内存块的数据拷贝到新内存，然后再释放掉原内存块。\n#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main() &#123;    int* p = (int*)malloc(4*sizeof(int));    for (int i = 0; i &lt; 4; i++) &#123;        p[i] = i*2;    &#125;//p的四个值分别是0,2,4,6    int* q = p;//使用q来记录p的地址        //再申请多块空间    int* a = (int*)malloc(4*sizeof(int));    int* b = (int*)malloc(4*sizeof(int));    int* c = (int*)malloc(4*sizeof(int));    //.....        p=realloc(p, 100000);\t//将p扩大到10000个字节    printf(&quot;p:%p\\n&quot;, p);//查看现在p的地址    printf(&quot;q:%p\\n&quot;, q);//查看原来p的地址    for (int i = 0; i &lt; 4; i++) &#123;        printf(&quot;p[%d]:%d &quot;,i,p[i]);//访问现在p内的数据    &#125;    free(p);    //free(q);    free(a);    free(b);    free(c);    p=q=a=b=c=NULL;\treturn 0;&#125;\n\n这是输出结果：可以看到p的地址发生了改变。\n\n这时就要考虑一个问题：要是realloc失败了呢？\n此时p就会得到一个NULL，而原数据就消失在内存的茫茫大海中了（并不会被释放）此时我们丢了数据又泄露了内存。而解决方法就是和上面一样：使用一个临时指针来接受返回值，若失败了仍然可以操作原内存。\nint *p = (int*)malloc(10 * sizeof(int));int *tmp = realloc(p, 1000 * sizeof(int));if(tmp!=NULL)&#123;    p=tmp;//这样就可以避免原指针丢失    tmp=NULL;&#125;\n\n动态内存常见的问题：\n内存泄露：使用了malloc但是未释放内存\n\n重复释放内存：\nfree(p);free(p);//对同已块空间连续释放两次，会导致程序崩溃//解决方法是：释放完内存后立即置空//即：free(p);p=NULL;//这时再free(p)就不会报错了\n\n迷航指针\nint* p = malloc(100);free(p);*p = 10;//这里操作已经释放的内存\n\n解决方法同上：操作完就置空free(p);p&#x3D;NULL\n\n对非动态开辟的内存free释放\nint main()&#123;\tint a = 10;    int* p = &amp;a;    free(p);//这里会报错&#125;\n\n使用free释放动态开辟内存的一部分\nint* p = (int*)malloc(10);p++;free(p);//这时p已经指向了下一个位置，解决方法是使用*(p+i)即p[i]或者使用新指针指向下一个位置\n\n申请多少内存就只能使用多少内存，不能越界访问。\n\n\n","categories":["学习笔记"],"tags":["C语言"]},{"title":"算法效率的度量","url":"/2025/03/20/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","content":"介绍想要知道自己写的代码的效率这么样，我们首先想到的就是把代码跑一遍，代码跑起来就知道自己写的代码运行的是快还是慢了。\n但是这样会存在一些问题：\n\n每台电脑性能是不一样的。如超级计算机和单片机\n\n不同的编程语言运行速度也不一样，编译型语言会比解释型语言要快一些\n\n和编译程序产生的机器指令的质量有关\n\n有些算法比如（导弹控制算法），是不能事后统计的\n\n\n因此我们需要别的方法来统计算法效率，能够排除外界因素对算法本身的干扰。要知道：算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。于是就有了时间复杂度和空间复杂度的概念。时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。\n时间复杂度时间复杂度：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。\n比如一个例子：\nvoid Func1(int N) &#123;    int count = 0;    for (int i = 0; i &lt; N ; ++ i)     &#123;        for (int j = 0; j &lt; N ; ++ j)        &#123;             ++count;         &#125;    &#125;    for (int k = 0; k &lt; 2 * N ; ++ k)     &#123;     ++count;     &#125;    int M = 10;    while (M--)     &#123;         ++count;     &#125;&#125;\n\n\n\n\n\n\n\n","categories":["数据结构"]}]